
//! This file has been generated by rustypy and contains bindings for Python.
//! rustypy version: 0.1.15
//! Python implementation build version: cpython-36

// IMPORTANT: This file will be replaced on new rustypy calls.
// Don't write on it directly, rather call functions from an other file.

#![allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused_imports,
    unused_variables)]

use libc::{c_long, c_double};
use cpython::{Python, ToPyObject, FromPyObject, ObjectProtocol,
              PythonObjectWithCheckedDowncast, PyObject, PyModule, PyErr,
              PyDict, NoArgs};
use std::collections::HashMap;

fn handle_import_error(err: PyErr) {
    println!("failed to load Python module, reason:
             {}", err.pvalue.unwrap());
}

/// Binds for Python module `primitives`
pub struct TQQERU<'a> {
    module: PyModule,
    py: &'a Python<'a>
}

impl<'a> TQQERU<'a> {
    /// Loads the module instance to the interpreter
    pub fn new(py: &'a Python) -> Option<TQQERU<'a>> {
        let module = py.import("test_package.basics.primitives");
        match module {
            Ok(m) => Some(
                TQQERU {
                    module: m,
                    py: py
                }),
            Err(exception) => {
                handle_import_error(exception);
                None
            }
        }
    }

    pub fn rust_bind_int_func(&self,
        int_arg: c_long
    ) -> c_long {

        let func = self.module.get(*(self.py), "rust_bind_int_func").unwrap();
        let int_arg = int_arg.to_py_object(*(self.py));
        let result = func.call(*(self.py), (int_arg, ), None).unwrap();
        let hQeRgG = result.extract::<c_long>(*(self.py)).unwrap();

        return hQeRgG

    }

    pub fn rust_bind_float_func(&self,
        float_arg: c_double
    ) -> c_double {

        let func = self.module.get(*(self.py), "rust_bind_float_func").unwrap();
        let float_arg = float_arg.to_py_object(*(self.py));
        let result = func.call(*(self.py), (float_arg, ), None).unwrap();
        let sjZGbD = result.extract::<c_double>(*(self.py)).unwrap();

        return sjZGbD

    }

    pub fn rust_bind_str_func(&self,
        str_arg: String
    ) -> String {

        let func = self.module.get(*(self.py), "rust_bind_str_func").unwrap();
        let str_arg = str_arg.to_py_object(*(self.py));
        let result = func.call(*(self.py), (str_arg, ), None).unwrap();
        let lWKmpr = result.extract::<String>(*(self.py)).unwrap();

        return lWKmpr

    }

    pub fn rust_bind_bool_func(&self,
        bool_arg: bool
    ) -> bool {

        let func = self.module.get(*(self.py), "rust_bind_bool_func").unwrap();
        let bool_arg = bool_arg.to_py_object(*(self.py));
        let result = func.call(*(self.py), (bool_arg, ), None).unwrap();
        let vCmAeD = result.extract::<bool>(*(self.py)).unwrap();

        return vCmAeD

    }

    pub fn other_prefix_tuple1(&self,
        tup_arg: (String, c_long)
    ) -> (String, c_long) {

        let func = self.module.get(*(self.py), "other_prefix_tuple1").unwrap();
        let tup_arg = tup_arg.to_py_object(*(self.py));
        let result = func.call(*(self.py), (tup_arg, ), None).unwrap();
            let ZSfdBn = result.get_item
            (*(self.py),0).unwrap().extract::<String>(*(self.py)).unwrap();
            let BbKGxz = result.get_item
            (*(self.py),1).unwrap().extract::<c_long>(*(self.py)).unwrap();

        return (ZSfdBn, BbKGxz)

    }

    pub fn other_prefix_tuple2(&self,
        tup_arg: (String, bool)
    ) -> (String, bool) {

        let func = self.module.get(*(self.py), "other_prefix_tuple2").unwrap();
        let tup_arg = tup_arg.to_py_object(*(self.py));
        let result = func.call(*(self.py), (tup_arg, ), None).unwrap();
            let tjZKTc = result.get_item
            (*(self.py),0).unwrap().extract::<String>(*(self.py)).unwrap();
            let nZBNzH = result.get_item
            (*(self.py),1).unwrap().extract::<bool>(*(self.py)).unwrap();

        return (tjZKTc, nZBNzH)

    }

    pub fn other_prefix_tuple3(&self,
        tup_arg1: c_double,
        tup_arg2: bool
    ) -> (c_double, bool) {

        let func = self.module.get(*(self.py), "other_prefix_tuple3").unwrap();
        let tup_arg1 = tup_arg1.to_py_object(*(self.py));
        let tup_arg2 = tup_arg2.to_py_object(*(self.py));
        let result = func.call(*(self.py), (tup_arg1, tup_arg2, ), None).unwrap();
            let xQdfGx = result.get_item
            (*(self.py),0).unwrap().extract::<c_double>(*(self.py)).unwrap();
            let axenLE = result.get_item
            (*(self.py),1).unwrap().extract::<bool>(*(self.py)).unwrap();

        return (xQdfGx, axenLE)

    }

}

/// Binds for Python module `nested_types`
pub struct NzkSLh<'a> {
    module: PyModule,
    py: &'a Python<'a>
}

impl<'a> NzkSLh<'a> {
    /// Loads the module instance to the interpreter
    pub fn new(py: &'a Python) -> Option<NzkSLh<'a>> {
        let module = py.import("test_package.basics.nested_types");
        match module {
            Ok(m) => Some(
                NzkSLh {
                    module: m,
                    py: py
                }),
            Err(exception) => {
                handle_import_error(exception);
                None
            }
        }
    }

    pub fn generic1(&self,
        g_arg: PyObject
    ) -> PyObject {

        let func = self.module.get(*(self.py), "generic1").unwrap();
        let g_arg = g_arg.to_py_object(*(self.py));
        let result = func.call(*(self.py), (g_arg, ), None).unwrap();
        let wKPFro = result.extract::<PyObject>(*(self.py)).unwrap();

        return wKPFro

    }

    pub fn dict1(&self,
        dict_arg: HashMap<String, c_long>
    ) -> HashMap<String, c_long> {

        let func = self.module.get(*(self.py), "dict1").unwrap();
        let dict_arg = dict_arg.to_py_object(*(self.py));
        let result = func.call(*(self.py), (dict_arg, ), None).unwrap();
        let mut ivebiT = HashMap::new();
        let ivebiT_d: PyDict = PyDict::downcast_from(*(self.py), result).unwrap();
        for (key, value) in ivebiT_d.items(*(self.py)) {
            let dict_key = key.extract::<String>(*(self.py)).unwrap();
            let dict_value = value.extract::<c_long>(*(self.py)).unwrap();
            ivebiT.insert(dict_key, dict_value);
        };

        return ivebiT

    }

    pub fn dict2(&self,
        dict_arg: HashMap<String, (String, bool)>
    ) -> HashMap<String, (String, bool)> {

        let func = self.module.get(*(self.py), "dict2").unwrap();
        let dict_arg = dict_arg.to_py_object(*(self.py));
        let result = func.call(*(self.py), (dict_arg, ), None).unwrap();
        let mut YtkRpA = HashMap::new();
        let YtkRpA_d: PyDict = PyDict::downcast_from(*(self.py), result).unwrap();
        for (key, value) in YtkRpA_d.items(*(self.py)) {
            let dict_key = key.extract::<String>(*(self.py)).unwrap();
            let PDABUM = value;
                let bGXANo = PDABUM.get_item
                (*(self.py),0).unwrap().extract::<String>(*(self.py)).unwrap();
                let cTVQma = PDABUM.get_item
                (*(self.py),1).unwrap().extract::<bool>(*(self.py)).unwrap();
            let dict_value = (bGXANo, cTVQma);
            YtkRpA.insert(dict_key, dict_value);
        };

        return YtkRpA

    }

    pub fn list1(&self,
        ls_arg: Vec<(c_double, bool)>
    ) -> Vec<String> {

        let func = self.module.get(*(self.py), "list1").unwrap();
        let ls_arg = ls_arg.to_py_object(*(self.py));
        let result = func.call(*(self.py), (ls_arg, ), None).unwrap();
        let mut QJzfjg = vec![];
        for e in result.iter(*(self.py)).unwrap() {
            QJzfjg.push(e.unwrap().extract::<String>(*(self.py)).unwrap());
        };

        return QJzfjg

    }

    pub fn cmpd_tuple(&self,
        tup_arg1: (c_long, (c_double, bool))
    ) -> (c_long, (String, bool), c_double) {

        let func = self.module.get(*(self.py), "cmpd_tuple").unwrap();
        let tup_arg1 = tup_arg1.to_py_object(*(self.py));
        let result = func.call(*(self.py), (tup_arg1, ), None).unwrap();
            let AvmIIl = result.get_item
            (*(self.py),0).unwrap().extract::<c_long>(*(self.py)).unwrap();
            let xSnblF = result.get_item(*(self.py), 1).unwrap();
                let XazVfV = xSnblF.get_item
                (*(self.py),0).unwrap().extract::<String>(*(self.py)).unwrap();
                let cVkpIy = xSnblF.get_item
                (*(self.py),1).unwrap().extract::<bool>(*(self.py)).unwrap();
            let hZGAmV = result.get_item
            (*(self.py),2).unwrap().extract::<c_double>(*(self.py)).unwrap();

        return (AvmIIl, (XazVfV, cVkpIy), hZGAmV)

    }

    pub fn cmpd_list_and_tuple(&self,
        ls_arg: Vec<((String, bool), PyObject)>
    ) -> Vec<(c_long, bool)> {

        let func = self.module.get(*(self.py), "cmpd_list_and_tuple").unwrap();
        let ls_arg = ls_arg.to_py_object(*(self.py));
        let result = func.call(*(self.py), (ls_arg, ), None).unwrap();
        let mut MragZL = vec![];
        for e in result.iter(*(self.py)).unwrap() {
            let iLbqHi = e.unwrap();
                let rgGell = iLbqHi.get_item
                (*(self.py),0).unwrap().extract::<c_long>(*(self.py)).unwrap();
                let mcrzNN = iLbqHi.get_item
                (*(self.py),1).unwrap().extract::<bool>(*(self.py)).unwrap();
            let iLbqHi = (rgGell, mcrzNN);
            MragZL.push(iLbqHi);
        };

        return MragZL

    }

    pub fn cmpd_list(&self,
        arg1: Vec<(c_long, bool)>,
        arg2: Vec<c_long>
    ) -> Vec<(Vec<c_long>, c_double)> {

        let func = self.module.get(*(self.py), "cmpd_list").unwrap();
        let arg1 = arg1.to_py_object(*(self.py));
        let arg2 = arg2.to_py_object(*(self.py));
        let result = func.call(*(self.py), (arg1, arg2, ), None).unwrap();
        let mut DBULBr = vec![];
        for e in result.iter(*(self.py)).unwrap() {
            let FgvXyd = e.unwrap();
                let fkRvVv = FgvXyd.get_item(*(self.py), 0).unwrap();
                let mut EZpBrG = vec![];
                for e in fkRvVv.iter(*(self.py)).unwrap() {
                    EZpBrG.push(e.unwrap().extract::<c_long>(*(self.py)).unwrap());
                };
                let fSyoAb = FgvXyd.get_item
                (*(self.py),1).unwrap().extract::<c_double>(*(self.py)).unwrap();
            let FgvXyd = (EZpBrG, fSyoAb);
            DBULBr.push(FgvXyd);
        };

        return DBULBr

    }

    pub fn cmpd_dict(&self,

    ) -> HashMap<String, HashMap<c_long, (String, bool)>> {

        let func = self.module.get(*(self.py), "cmpd_dict").unwrap();

        let result = func.call(*(self.py), NoArgs, None).unwrap();
        let mut lIpKyV = HashMap::new();
        let lIpKyV_d: PyDict = PyDict::downcast_from(*(self.py), result).unwrap();
        for (key, value) in lIpKyV_d.items(*(self.py)) {
            let dict_key = key.extract::<String>(*(self.py)).unwrap();
            let mut OGNwsn = HashMap::new();
            let OGNwsn_d: PyDict = PyDict::downcast_from(*(self.py), value).unwrap();
            for (key, value) in OGNwsn_d.items(*(self.py)) {
                let dict_key = key.extract::<c_long>(*(self.py)).unwrap();
                let kyPjUo = value;
                    let CfgXOx = kyPjUo.get_item
                    (*(self.py),0).unwrap().extract::<String>(*(self.py)).unwrap();
                    let oFXMCz = kyPjUo.get_item
                    (*(self.py),1).unwrap().extract::<bool>(*(self.py)).unwrap();
                let dict_value = (CfgXOx, oFXMCz);
                OGNwsn.insert(dict_key, dict_value);
            };
            let dict_value = OGNwsn;
            lIpKyV.insert(dict_key, dict_value);
        };

        return lIpKyV

    }

    pub fn cmpd_list_and_dict(&self,

    ) -> Vec<HashMap<c_long, (String, bool)>> {

        let func = self.module.get(*(self.py), "cmpd_list_and_dict").unwrap();

        let result = func.call(*(self.py), NoArgs, None).unwrap();
        let mut mCPCAf = vec![];
        for e in result.iter(*(self.py)).unwrap() {
            let IkicHt = e.unwrap();
            let mut uwICOM = HashMap::new();
            let uwICOM_d: PyDict = PyDict::downcast_from(*(self.py), IkicHt).unwrap();
            for (key, value) in uwICOM_d.items(*(self.py)) {
                let dict_key = key.extract::<c_long>(*(self.py)).unwrap();
                let VZkjcf = value;
                    let hMgjaN = VZkjcf.get_item
                    (*(self.py),0).unwrap().extract::<String>(*(self.py)).unwrap();
                    let yyGwKj = VZkjcf.get_item
                    (*(self.py),1).unwrap().extract::<bool>(*(self.py)).unwrap();
                let dict_value = (hMgjaN, yyGwKj);
                uwICOM.insert(dict_key, dict_value);
            };
            mCPCAf.push(uwICOM);
        };

        return mCPCAf

    }

    pub fn cmpd_dict_and_ls(&self,

    ) -> HashMap<c_long, Vec<c_double>> {

        let func = self.module.get(*(self.py), "cmpd_dict_and_ls").unwrap();

        let result = func.call(*(self.py), NoArgs, None).unwrap();
        let mut fWhHPF = HashMap::new();
        let fWhHPF_d: PyDict = PyDict::downcast_from(*(self.py), result).unwrap();
        for (key, value) in fWhHPF_d.items(*(self.py)) {
            let dict_key = key.extract::<c_long>(*(self.py)).unwrap();
            let mut jOKDoH = vec![];
            for e in value.iter(*(self.py)).unwrap() {
                jOKDoH.push(e.unwrap().extract::<c_double>(*(self.py)).unwrap());
            };
            let dict_value = jOKDoH;
            fWhHPF.insert(dict_key, dict_value);
        };

        return fWhHPF

    }

}

/// Struct for folder `basics`
pub struct LSNqrJ<'a> {
    pub primitives: TQQERU<'a>,
    pub nested_types: NzkSLh<'a>,

}

impl<'a> LSNqrJ<'a> {
    /// Loads the module instance to the interpreter
    pub fn new(py: &'a Python) -> Option<LSNqrJ<'a>> {
        Some(LSNqrJ {
            primitives: TQQERU::new(&py).unwrap(),
            nested_types: NzkSLh::new(&py).unwrap(),

        })
    }
}

/// Binds for Python module `call_from_subfirst`
pub struct hYudnm<'a> {
    module: PyModule,
    py: &'a Python<'a>
}

impl<'a> hYudnm<'a> {
    /// Loads the module instance to the interpreter
    pub fn new(py: &'a Python) -> Option<hYudnm<'a>> {
        let module = py.import("test_package.firstdir.subfirstdir.call_from_subfirst");
        match module {
            Ok(m) => Some(
                hYudnm {
                    module: m,
                    py: py
                }),
            Err(exception) => {
                handle_import_error(exception);
                None
            }
        }
    }

    pub fn subfirst_module(&self,

    )  {

        let func = self.module.get(*(self.py), "subfirst_module").unwrap();

        let result = func.call(*(self.py), NoArgs, None).unwrap();
        let XJTiyT = result.extract::<PyObject>(*(self.py)).unwrap();

        return 

    }

}

/// Struct for folder `subfirstdir`
pub struct vpLpPZ<'a> {
    pub call_from_subfirst: hYudnm<'a>,

}

impl<'a> vpLpPZ<'a> {
    /// Loads the module instance to the interpreter
    pub fn new(py: &'a Python) -> Option<vpLpPZ<'a>> {
        Some(vpLpPZ {
            call_from_subfirst: hYudnm::new(&py).unwrap(),

        })
    }
}

/// Binds for Python module `call_from_first`
pub struct REtmEn<'a> {
    module: PyModule,
    py: &'a Python<'a>
}

impl<'a> REtmEn<'a> {
    /// Loads the module instance to the interpreter
    pub fn new(py: &'a Python) -> Option<REtmEn<'a>> {
        let module = py.import("test_package.firstdir.call_from_first");
        match module {
            Ok(m) => Some(
                REtmEn {
                    module: m,
                    py: py
                }),
            Err(exception) => {
                handle_import_error(exception);
                None
            }
        }
    }

    pub fn first_module(&self,

    )  {

        let func = self.module.get(*(self.py), "first_module").unwrap();

        let result = func.call(*(self.py), NoArgs, None).unwrap();
        let PNvUdO = result.extract::<PyObject>(*(self.py)).unwrap();

        return 

    }

}

/// Struct for folder `firstdir`
pub struct xrokUH<'a> {
    pub subfirstdir: vpLpPZ<'a>,
    pub call_from_first: REtmEn<'a>,

}

impl<'a> xrokUH<'a> {
    /// Loads the module instance to the interpreter
    pub fn new(py: &'a Python) -> Option<xrokUH<'a>> {
        Some(xrokUH {
            subfirstdir: vpLpPZ::new(&py).unwrap(),
            call_from_first: REtmEn::new(&py).unwrap(),

        })
    }
}

/// Binds for Python module `root_module_2`
pub struct WNYhcn<'a> {
    module: PyModule,
    py: &'a Python<'a>
}

impl<'a> WNYhcn<'a> {
    /// Loads the module instance to the interpreter
    pub fn new(py: &'a Python) -> Option<WNYhcn<'a>> {
        let module = py.import("test_package.root_module_2");
        match module {
            Ok(m) => Some(
                WNYhcn {
                    module: m,
                    py: py
                }),
            Err(exception) => {
                handle_import_error(exception);
                None
            }
        }
    }

    pub fn root_module_2(&self,

    )  {

        let func = self.module.get(*(self.py), "root_module_2").unwrap();

        let result = func.call(*(self.py), NoArgs, None).unwrap();
        let zqZjNc = result.extract::<PyObject>(*(self.py)).unwrap();

        return 

    }

}

/// Binds for Python module `root_module_1`
pub struct FrTDuW<'a> {
    module: PyModule,
    py: &'a Python<'a>
}

impl<'a> FrTDuW<'a> {
    /// Loads the module instance to the interpreter
    pub fn new(py: &'a Python) -> Option<FrTDuW<'a>> {
        let module = py.import("test_package.root_module_1");
        match module {
            Ok(m) => Some(
                FrTDuW {
                    module: m,
                    py: py
                }),
            Err(exception) => {
                handle_import_error(exception);
                None
            }
        }
    }

    pub fn root_module_1(&self,

    )  {

        let func = self.module.get(*(self.py), "root_module_1").unwrap();

        let result = func.call(*(self.py), NoArgs, None).unwrap();
        let Rjgpxs = result.extract::<PyObject>(*(self.py)).unwrap();

        return 

    }

}

/// Struct for folder `test_package`
pub struct bwJNXv<'a> {
    pub basics: LSNqrJ<'a>,
    pub firstdir: xrokUH<'a>,
    pub root_module_2: WNYhcn<'a>,
    pub root_module_1: FrTDuW<'a>,

}

impl<'a> bwJNXv<'a> {
    /// Loads the module instance to the interpreter
    pub fn new(py: &'a Python) -> Option<bwJNXv<'a>> {
        Some(bwJNXv {
            basics: LSNqrJ::new(&py).unwrap(),
            firstdir: xrokUH::new(&py).unwrap(),
            root_module_2: WNYhcn::new(&py).unwrap(),
            root_module_1: FrTDuW::new(&py).unwrap(),

        })
    }
}

/// Python module manager
pub struct PyModules<'a> {
    pub basics: LSNqrJ<'a>,
    pub firstdir: xrokUH<'a>,
    pub root_module_2: WNYhcn<'a>,
    pub root_module_1: FrTDuW<'a>,

}

impl<'a> PyModules<'a> {
    pub fn new(py: &'a Python) -> PyModules<'a> {
        PyModules {
            basics: LSNqrJ::new(&py).unwrap(),
            firstdir: xrokUH::new(&py).unwrap(),
            root_module_2: WNYhcn::new(&py).unwrap(),
            root_module_1: FrTDuW::new(&py).unwrap(),

        }
    }
}
